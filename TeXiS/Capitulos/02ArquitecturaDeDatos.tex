%---------------------------------------------------------------------
%
%                          Capítulo 2 - Arquitectura de datos
%
%---------------------------------------------------------------------

\chapter{Arquitectura de datos}

\begin{resumen}

En esta sección, se va a explicar la arquitectura de datos de la solución implementada así como la justificación de la misma frente a otras alternativas que se presentarán en el capítulo. La memoria está estructurada siguendo el modelo clásico cliente-servidor en la que el ordenador realiza la función de servidor y el móvil de cliente. 
\end{resumen}


%-------------------------------------------------------------------
\section{Bases de datos}
\paragraph{}
En la solución implementada, era crucial disponer de un servidor para que los profesionales que tratasen directamente con el paciente pudiesen supervisar los registros del mismo sin tener que esperar a la visita física del paciente para analizar los datos registrados por el dispositivo IOT. El primer dilema que se plantea es si almacenar los datos generados en un servidor externo como Azure, Amazon Web Services, Google Cloud o Alibaba Cloud o por contra almacenarlos en un servidor propio. Que dicho almacenamiento sea en un servidor externo tiene como principal ventaja la comodidad del programador, pues estos servidores externos suelen añadir servicios adicionales como la inclusión de bases de datos de distintos tipos ya configuradas así como distintos tipos de mecanismos de seguridad frente a ataques externos. La principal desventaja de estas soluciones es la falta de flexibilidad frente a la implementación en servidores propios así como el hecho de que en un servidor propio los únicos costes tecnológicos son la luz consumida por el dispositivo de almacenamiento (como puede ser un ordenador) y el propio dispositivo. Tras sopesar ambas opciones, se decide utilizar un servidor propio, pues la desventaja del mayor tiempo de desarrollo necesario para la puesta en marcha se ve minimizada por la existencia de numerosos ejemplos de servidores bastante similares al que se requiere para este trabajo.

\paragraph{}
En lo que respecta al tipo de base de datos a utilizar en el servidor, existe la posibilidad de utilizar bases de datos relacionales y no relacionales. A continuación se va a describir en qué consiste cada uno de estos tipos de base de datos con el fin de justificar después la elección del tipo de base de datos utilizada.

\subsection{Bases de datos relaciones}
\paragraph{}
Una base de datos completamente relacional es utilizada generalmente para almacenar lo que se denominan datos \textit{clásicos} en la que al realizar una consulta sobre los mismos no existe ninguna incertidumbre, se obtienen la tupla de valores en la forma exacta en la que se ha solicitado \citep{jimenez2016implementacion}. Estas bases de datos a su vez deben de tener definidas al menos las reglas de inserción, actualización y eliminación de datos \citep{codd1979extending}.

\paragraph{}
Estas bases de datos tienen como principales desventajas la menor escalabilidad respecto a bases de datos no relacionales y la dificultad para lidiar con datos que no tengan una estructura previamente conocida y/o fuertemente tipificada. Por otro lado, debido al largo tiempo que estas bases de datos llevan siendo utilizadas, existe una gran comunidad de desarrolladores detrás de lenguajes como SQL lo que facilita su implementación.

\subsection{Bases de datos no relacionales}
\paragraph{}
Las bases de datos no relacionales se basan en una mayor flexibilidad a la hora de almacenar datos con atributos y contenido dispar, pudiendo añadir nuevos atributos sin tener que modificar el contenido de otros registros. Estas bases de datos suelen facilitar la escalabilidad horizontal así como la posibilidad de replicar y distribuir los datos entre los distintos servidores, al poderse particionar los datos por patrones.

\paragraph{}
Entre las bases de datos no relacionales o no-sql podemos encontrar los siguientes tipos \citep{aws-nosql}:

\begin{itemize}
\item Clave-valor: son altamente divisibles y permiten un gran escalado horizontal. Algunos de sus casos de uso son los videojuegos, la tecnología publicitaria o IOT. Algunos ejemplos de estas bases de datos son Redis y Cassandra.
\item Documento: es un modelo que no se basa en filas y columnas desnormalizadas, sino que los datos se presentan en formatos como JSON. Algunos ejemplos de estas bases de datos son MongoDB y CouchDB.
\item Gráficas: son principalmente usadas en aplicaciones que trabajan con conjuntos de datos fuertemente conectados, como es el caso de los datos relacionados con las redes sociales, motores de recomendaciones y gráficos de conocimiento. Entre este tipo de base de datos se encuentran Neo4j y OrientDB.
\end{itemize}

\subsection{Justificación de la base de datos elegida}
\paragraph{}
Poniendo en la balanza los elementos mencionados en las dos subsecciones previas, se ha considerado que las bases de datos no relacionales son las que mejor se adaptan al uso que se va a hacer del servidor. El motivo principal es el hecho de que los datos no tienen necesariamente que estar fuertemente estructurados; puede suceder que la pulsera de un paciente en algún momento no guarde un dato concreto por errores de hardware de la misma o que utilice una pulsera que no disponga de todos los indicadores inicialmente previstos, lo que en el caso de las bases de datos no relacionales se puede gestionar con facilidad sin necesidad de guardar columnas con el valor nulo en cada sensorización.

\paragraph{}
Otros factores relevantes a la hora de elegir un lenguaje para una base de datos son los siguientes:
\begin{enumerate}
\item Que el lenguaje utilizado sea de software libre para que así no haya limitaciones en el conocimiento que se puede tener sobre el mismo.
\item Fácil interacción con dicha base de datos en el lenguaje en el que se vaya a programar el cliente y/o el servidor que se pretenda que tenga algún tipo de acceso directo a la misma. Esta facilidad es subjetiva y no es el propósito de este trabajo buscar métodos que estandaricen dicha medición entre distintos programadores. Por contra, como el desarrollador de la solución es la persona que escribe esta misma memoria, será su criterio intencionadamente subjetivo el que prevalezca tanto en este como en el siguiente factor.
\item Fácil interacción en el medio tecnológico en el que se vaya a interactuar con la base de datos (un ordenador, un Arduino, un móvil etc).
\item Una comunidad de desarrolladores que facilite la resolución de dudas. Esto puede verse reflejado principalmente en los índices de popularidad de dichos lenguajes en los foros de programación como Stackoverflow.
\item Versiones estables de dicho lenguaje de la base de datos para el fin que se le quiera dar.
\item La experiencia previa del desarrollador con dicho lenguaje, que puede hacer que disminuya el tiempo necesario de programación disminuyendo por tanto el tiempo necesario para el desarrollo de la solución.
\end{enumerate}

\paragraph{}
En nuestro caso particular, esto implica la necesidad de un lenguaje de fácil interacción en Android y Python. En el caso de Android, esta interacción debe ser tanto a nivel de cliente (conexión con el servicio web para sincronizar los datos) como de servidor (servidor local en el que guardar los datos antes de ser sincronizados).


\paragraph{}
Añadiendo estos nuevos factores a los ya mencionados, los lenguajes de bases de datos que se considera que podrían llegar a cumplir esta función son Redis, Cassandra, MongoDB y Couchbase, al ser todos ellos de software libre (punto 1), haya una fácil interaccion en la parte del servidor ejecutado en un ordenador y cuyas interacciones están definidas en Python (punto 2 y 3) y todos ellos llevan por lo menos siete años siendo públicos.

\paragraph{}
Entre estos lenguajes, Redis y Cassandra son descartados por una mezcla entre el punto 3 y el punto 4:  a pesar de encontrarse ambas entre las quince bases de datos más utilizadas según la encuesta de Stackoverflow de 2018 \citep{so-db}, ni siquiera en la propia documentación de las páginas oficiales de estos lenguajes se explica la manera en la que se producirían estas interacciones desde Android.

\paragraph{}
En el caso de Couchbase y MongoDB, ambos cuentan con documentación para Android en sus respectivas páginas oficiales así como proyectos de ejemplo en los que queda bastante claro la manera de interactuar con las bases de datos. En el caso de MongoDB, se cuenta con experiencia previa con dicho lenguaje (punto 6), mientras que a pesar de no haber usado previamente Couchbase, esta cuenta con un sistema de consultas de datos llamado N1QL cuya sintaxis es bastante más intuitiva que la de MongoDB. A su vez, ambas cuentan con contenedores Docker ya configurados así como tutoriales que facilitan su puesta en marcha y modificación. Teniendo todo esto en cuenta, realmente se podría haber elegido cualquiera de estas dos soluciones para este proyecto, decantándose finalmente por utilizar Couchbase debido a que se considera que N1QL facilita tener un código limpio y mejor estructurado.

\section{Elementos tecnológicos}
\subsection{Cliente}
%TODO: móvil Android + pulsera
\subsection{Servidor}
%TODO

\section{Conexiones entre elementos tecnológicos}
\subsection{Conexión entre la pulsera inteligente y el móvil Android}
\paragraph{}
La pulsera inteligente se conecta con el móvil a traves de Bluetooth Low Energy(BLE), que es la cuarta version del protocolo Bluetooth. Es un protocolo de comunicación inalámbrica que emite en la frecuencia 2.4Ghz de bajo consumo que en entornos experimentales ha llegado a tener un alcance de más de un kilómetro \citep{akhayad2016bluetooth}. Está diseñado para el intercambio de información ligera que no requiera de alta velocidad (su velocidad de transferencia máxima es de 1Mbps). En lo que respecta a la seguridad, una vez se han acoplado los dos dispositivos, los datos emitidos se encriptan mediante Advaced Encryption Standard(AES) 128.

\paragraph{}
Por último, un dato a considerar es que este protocolo no es compatible con versiones previas de Bluetooth, por lo que para el emparejamiento entre la pulsera inteligente y el móvil Android será necesario que el usuario disponda de un teléfono móvil de al menos el año 2013 o 2014, que es cuando se popularizó este protocolo entre dispositivos móviles.

\paragraph{}
Este no es un protocolo que se haya podido elegir de manera aislada respecto a otros protocolos de bajo consumo, sino que se partía con la limitación de la oferta del propio hardware de tanto la pulsera como de los protocolos más comunes entre los teléfonos móviles, lo que en este caso obliga \textit{de facto} a utilizar el protocolo BLE.

\subsection{Conexión entre el móvil Android y el servidor}
\paragraph{}
Una vez han llegado los datos de las sensorizaciones al móvil, estos datos se envían al servidor. Para realizar este envío, las opciones que se han barajado han sido realizarlas mediante peticiones Hypertext Transfer Protocol(HTTP), Message Queuing Telemetry Transport (MQTT) o Advanced Message Queuing Protocol (AMQP).

\paragraph{}
La principal diferencia entre las peticiones HTTP y las peticiones MQTT Y AMQP es el consumo de recursos de estas soluciones, siendo MQTT un protocolo más eficiente en el envío de paquetes que HTTP \citep{yokotani2016comparison}, que es un elemento crítico en IOT, lo que implica el descarte de este protocolo.

\paragraph{}
El protocolo MQTT es un protocolo unidireccional entre un publicador y un suscriptor a través de unos identificadores del canal llamado tópicos. En lo que respecta a asegurar que los datos del publicador han llegado al suscriptor, existen tres niveles de Quality of Service (QoS) que se pueden definir por cada tópico. En el nivel cero, se envía el dato al menos una vez pero no se garantiza que ese dato ha llegado al suscriptor. En el nivel uno, el suscriptor debe enviar la confirmación de que le ha llegado el dato en cuestión al menos una vez. Por último, en el nivel dos, se garantiza que el dato llega exactamente una vez al suscriptor.

\paragraph{}
AMQP se diferencia principalmente de MQTT en que en AMQP el servidor puede mandar mensajes de vuelta al cliente que vayan más allá de los mensajes numéricos de posibles errores. Esto tiene como coste un mayor consumo de ancho de banda, pero mucho menor que en el caso de HTTP. En el caso de MQTT si se quiere establecer esta comunicación bidireccional es necesario crear dos canales entre ambos elementos.

\paragraph{}
En lo que respecta a la autenticación y la ciberseguridad, ambos protocolos pueden ser integrados con TLS. El ancho de banda de esta solución en MQTT únicamente se ve notablemente resentida en la etapa de autenticación, mientras que en las fases posteriores de envío de datos el rendimiento es muy similar a las soluciones sin TLS \citep{hivemq}.

\paragraph{}
En este proyecto, se ha decidido utilizar RabbitMQ, que es una solución de software libre que facilita la implementación de MQTT y AMQP así como la inclusión de TLS. Como esta solución permite la implementación en Python (para el servidor) y Java (para el cliente), cumple todos los requisitos para el despliegue de nuestro software. A su vez, al utilizar RabbitMQ en lugar de directamente AMQP o MQTT, esto facilita que en un futuro se pudiese migrar la solución a MQTT, pues debajo de RabbitMQ se está ejecutando AMQP por la versatilidad que da el hecho de que los canales de comunicación entre cliente y servidor sean bidireccionales.

\section{Ciberseguridad}
\paragraph{}
Como se va a tratar con datos biométricos sensibles, es importante asegurarse de que esta información no acabe en manos indeseadas. Con este fin, se han tomado las siguientes medidas de seguridad:
\begin{enumerate}
\item Autenticación tanto en la base de datos del móvil como en la base de datos del servidor. En el caso de la base de datos del servidor, se debe permitir las conexiones externas a través del servicio web de Python.
\item Encriptación de los datos de ambas bases de datos, para que aunque un atacante consiguiese tener acceso al dispositivo, no pudiese obtener información de la propia base de datos.
\item Encriptación punto a punto, para evitar ataques de sniffer.
\end{enumerate}

\paragraph{}
El punto más vulnerable de nuestra solución será en lo que respecta al envío de datos de la pulsera al dispositivo Android, pues este envío viene configurado por el propio desarrollador de la pulsera y este envío se realiza sin ningún tipo de cifrado, por lo que si un atacante se hace con el control del dispositivo Android, podrá leer directamente los datos que son enviados por BLE sin tener que forzar ni nuestra app ni nuestras bases de datos.

\paragraph{}
En lo que respecta a la autentificación en las bases de datos, MongoDB cuenta con el método SCRAM, basado a su vez en el método IETF RFC 5802 \citep{ietf}. Para la encriptación de los datos almacenados, utiliza AES256-GCM. También provee de herramientas para el encriptado punto a punto al acceder a servidores externos. Sin embargo, como no se va a exponer directamente la base de datos sino que estas operaciones se van a realizar a través del servicio web, esta parte del protocolo de seguridad de MongoDB no va a ser utilizada.

\paragraph{}
[TODO: encriptación en la capa de transporte]


\subsection{Autenticación y autorización en el servidor web}
\paragraph{}
El servidor web requiere que los usuarios se autentiquen antes de poder operar con los datos de las mediciones para evitar accesos indeseados a la base de datos con los registros de sensorizaciones. A continuación se van a describir distintos métodos de autenticación que se pueden implementar para a continuación intentar justificar el método utilizado.

\begin{itemize}
\item Autenticación básica: el usuario se identifica mediante una tupla usuario-contraseña que son enviados en texto plano. Esto tiene numerosas vulnerabilidades, como la escucha de terceros así como el hecho de que al no contar con claves API que funcionen por debajo de la contraseña del usuario, se impide que el responsable de la seguridad del servidor pueda cambiar las claves API en caso de detectar alguna posible vulnerabilidad. Por contra, en este caso por cada cambio que se realice se requiere la interacción del usuario.

\item OAuth 1.0: es un protocolo basado en la autorización en lugar de la autenticación en la que los consumidores y los proveedores no intercambian las claves de acceso sino claves que autorizan al consumidor para realizar determinadas operaciones. Es un modelo similar al de las claves de coches de lujo de tipo valet, que permiten acceder sólo a recursos concretos del coche (por ejemplo, con estas llaves se puede conducir el coche pero no utilizar el ordenador de abordo) y sólo durante un periodo de uso concreto (por ejemplo, la llave deja de funcionar si se sobrepasan los 10 kilómetros de autonomía que se establecen para que un chófer pueda aparcar dicho coche pero no pueda utilizarlo para dar una vuelta), en contraposición de la llave del coche tradicional que autoriza para realizar cualquier operación sin que esta llave nunca caduque \citep{oauth1}. Los tres actores que intervienen en este protocolo son el usuario, el consumidor y el proveedor del servicio. A continuación se van a desgranar a partir del artículo de Rob Sobers \citeyear{robsobers} el flujo que sigue un usuario cuando accede correctamente a un recurso protegido:
\begin{enumerate}
\item El usuario muestra su intención de acceder a un determinado recurso.
\item Este consumidor pregunta al proveedor del servicio si puede darle permiso al usuario. El proveedor de servicio provee al consumidor un token y un secreto para acceder al recurso.
\item El consumidor le envía al usuario este token y su correspondiente secreto. 
\item El usuario le envía al proveedor del servicio una solicitud para que autorice el token que le ha enviado el consumidor, respondiendo si dicho token es correcto.
\item El consumidor cambia con el proveedor del servicio el token de solicitud obtenido en el paso dos por un token de acceso.
\item El consumidor accede al recurso protegido con su token.
\end{enumerate}
%TODO: add flow diagram and explain previous steps referencing the flow diagram (perhaps mix it with Twitter's example from Rob Sobers).
%https://oauth.net/core/1.0/ Flow diagram OAuth1
%https://tools.ietf.org/html/rfc6749 Flow diagram OAuth2
%https://docs.spring.io/spring-social/docs/1.1.0.RELEASE/reference/htmlsingle/#section_oauth2ServiceProviders Flow diagram of both OAuth1 and OAuth2. <--- Use this
%https://hueniverse.com/oauth-2-0-and-the-road-to-hell-8eec45921529 Limitations OAuth2

\item OAuth 2.0: como su nombre indica, es la segunda versión del protocolo Oauth 1.0, que aumenta significativamente su usabilidad. Las principales diferencias de OAuth 2.0 frente a OAuth 1.0 son las siguientes \citep{oauth2}:
\begin{itemize}
\item Mejor experiencia de usuario para accesos desde dispositivos móviles: para usar OAuth 1.0 en las apps, era necesario redirigir al usuario al navegador, que este introdujese ahí sus credenciales, en caso de que fueran correctos copiar el token de autorización e introducirlo de vuelta en la app. En OAuth 2.0 este proceso se puede realizar sin tener que salir de la propia app.
\item Ya no se requiere que el usuario tenga el sistema de cifrado HMAC, al proveer la opción de enviar los datos a través de HTTPS.
\item Simplificación de las firmas: ya no hace falta una codificación concreta y utiliza un único secreto en lugar de dos.
\item Se incluye la posibilidad de incluir tokens de actualización. Estos son tokens que se envían junto a los credenciales del usuario cuando el token de acceso ha caducado para solicitar un nuevo token. Este token por tanto, no tiene ninguna utilidad si no se tienen a su vez los credenciales de acceso.
\item Separación clara de roles entre el servidor que responde a las solicitudes de OAuth y los servidores encargados de la autenticación del usuario.
\end{itemize}

\item JWT (Json Web Token authentification): es un método que utiliza un objeto JSON para autentificar usuarios o enviar información de forma segura. La información que se manda puede ser firmada con HMAC-SHA256, o con RSA o ECDSA \citep{jwt}. El objeto JSON que se envía tiene la siguiente estructura \citep{rfc7519}:
\begin{itemize}
    \item Cabecera: es donde se define el algoritmo utilizado para realizar la firma (HMAC, RSA o ECDSA).
    \item Carga útil o \textit{payload}: es donde se realiza la petición que debe ser contrastada. Existen tres tipos de peticiones:
    \begin{itemize}
        \item Peticiones registradas: son una serie de peticiones predefinidas que se recomienda usar. Entre ellas, se encuentra \texttt{iss}, que identifica al emisor del JSON o \texttt{exp}, que establece el momento en el que el JSON deja de ser válido.
        \item Peticiones públicas: es una lista de peticiones más extensa que las registradas en las que por ejemplo se puede definir el correo electrónico, la zona horaria o la localización del emisor, tal como se puede consultar en la página web de IANA \citeyear{iana}.
        \item Peticiones privadas: son peticiones personalizadas que el productor y consumidor del objeto JWT previamente han decidido usar.
    \end{itemize}
    \item Firma: se incluye la firma de la cabecera y de la carga útil.
\end{itemize}

\item TLS (Transport Layer Security)/SSL(Secure Socket Layer): son dos protocolos de critografía asimétrica que se suelen utilizar indistintamente y que se usan para establecer comunicaciones seguras en la red. TLS contiene dos capas: la capa para el apretón de manos, en la que autentifica a ambas partes, y la capa en la que se provee seguridad en cuanto a la integridad del mensaje \citep{evaldsson2015evaluate}. Una de sus principales fortalezas es la interoperabilidad: no se impone un método de encriptación entre el cliente y el servidor, sino que se negocia dicho método entre ambos, lo que permite renovar viejos protocolos de encriptación cuando estos quedan obsoletos \citep{carlsson2018comparison}. Su aplicación más conocida es para establecer comunicaciones seguras entre el servidor y el navegador web al realizar peticiones HTTP. Entre estos dos protocolos, SSL es el protocolo de seguridad más utilizado para la autenticación en Internet \citep{viega2002network}.


\end{itemize}
